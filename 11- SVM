# -*- coding: utf-8 -*-
"""
Created on Mon Dec  1 19:42:29 2025

@author: Lenovo
"""

import pandas as pd
from sklearn import svm
from sklearn.metrics import confusion_matrix,accuracy_score,roc_curve,classification_report

def nullCount(data):
    
    null_count = data.isnull().sum()
    null_percentage = (data.isnull().sum() / len(data)) * 100

    # Combine into a single DataFrame
    null_summary = pd.DataFrame({
        'Null_Count': null_count,
        'Null_Percentage': null_percentage
    })
    
    return null_summary

def one_hot_encode_columns(data, columns):
    """
    One-hot encodes specified columns in a DataFrame (with drop_first=True) and returns the updated DataFrame.
    
    Parameters:
    - data (pd.DataFrame): The input DataFrame.
    - columns (list): List of column names to one-hot encode.
    
    Returns:
    - pd.DataFrame: The transformed DataFrame with one-hot encoded columns.
    """
    data = data.copy()
    dummies_list = []
    
    for col in columns:
        if col in data.columns:
            dummies = pd.get_dummies(data[col], prefix=col, drop_first=True)
            dummies_list.append(dummies)
            data = data.drop(col, axis=1)
    
    if dummies_list:
        data = pd.concat([data] + dummies_list, axis=1)
    
    return data

def ordinal_encode_columns(data, columns, order_dict):
    """
    Ordinally encodes specified columns in a DataFrame using provided category orders.

    Parameters:
    - data (pd.DataFrame): The input DataFrame.
    - columns (list): List of column names to encode.
    - order_dict (dict): A dictionary where keys are column names and values are lists defining category order.

    Returns:
    - pd.DataFrame: The transformed DataFrame with ordinally encoded columns.
    """
    data = data.copy()
    
    for col in columns:
        if col in data.columns and col in order_dict:
            category_order = order_dict[col]
            cat_type = pd.api.types.CategoricalDtype(categories=category_order, ordered=True)
            data[col] = data[col].astype(cat_type).cat.codes
    
    return data

def SupportVectorMachine(x_train, x_test, y_train, y_test, kernel='linear',C=1.0,gamma='scale'):
    model = svm.SVC(kernel=kernel,C=C,gamma=gamma)
    model = model.fit(x_train, y_train)
    svm_predict = model.predict(x_test)
    
    svm_conf_matrix = confusion_matrix(y_test, svm_predict)
    svm_acc_score = accuracy_score(y_test, svm_predict)
    
    print("confusion matrix")
    print(svm_conf_matrix)
    print("\n")
    print("Accuracy of SVM Classification:",svm_acc_score*100,'\n')
    print(classification_report(y_test,svm_predict))

    return model

# reading data    
data = pd.read_csv(r"BankChurnersData.csv")

# checking null data
null_count = nullCount(data)

numeric_cols = data.select_dtypes(exclude=['object']).columns.tolist()
string_cols = data.select_dtypes(include=['object']).columns.tolist()

# removing non required columns
remove_cols = ['CLIENTNUM']
numeric_cols = [col for col in numeric_cols if col not in remove_cols]
string_cols = [col for col in string_cols if col not in remove_cols]

data = data[numeric_cols + string_cols]

# One-hot encode
cols_to_one_hot_encode = ['Attrition_Flag', 'Gender', 'Marital_Status', 'Card_Category']
data = one_hot_encode_columns(data, cols_to_one_hot_encode)

# ordinal encode
cols_to_ordinal_encode = ['Education_Level', 'Income_Category']
unique_values = {col: data[col].unique() for col in cols_to_ordinal_encode}

unknown_count = (data['Education_Level'] == 'Unknown').sum()
unknown_count = (data['Income_Category'] == 'Unknown').sum()

order_dict = {
    'Education_Level': ['Uneducated', 'Unknown', 'High School', 'College', 'Graduate', 'Post-Graduate', 'Doctorate'],
    'Income_Category': ['Less than $40K', '$40K - $60K', '$60K - $80K', '$80K - $120K', '$120K +']
}

data = ordinal_encode_columns(data, cols_to_ordinal_encode, order_dict)

# Train Test Split
from sklearn.model_selection import train_test_split
df_train, df_test = train_test_split(data, train_size = 0.8, test_size = 0.2, random_state = 100)

y_train = df_train.pop('Attrition_Flag_Existing Customer') #labels in training data
x_train = df_train # features in training data

y_test = df_test.pop('Attrition_Flag_Existing Customer') #lables in test data
x_test = df_test # features in test data

# data scaling
from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler()

x_train = scaler.fit_transform(x_train)
x_test = scaler.transform(x_test)

# Support Vector Machine
model_linear = SupportVectorMachine(x_train, x_test, y_train, y_test,kernel='linear',C=1.0)
model_non_linear = SupportVectorMachine(x_train, x_test, y_train, y_test,kernel='rbf',C=1.0,gamma=0.1)

